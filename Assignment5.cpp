/*
Program Name: EECS 348 Assignment 5
Description: Email Prioritization Program
Inputs: Test file labeled ASsignment5_Test_File.txt
Output: Next email and numbr o funread emails

Collaborators: Code generated by Deepseek AI, referenced Assignment 1 for functionality and structure
               author debugged and annotated the AI generated code

Author: Aiman Boullaouz
Creation Date: 2/25/20225
*/

#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <queue>
#include <map>
#include <algorithm>
#include <cctype>
#include <stdexcept>

using namespace std;

class Email {
public:
    static map<string, int> PRIORITY;

    string category;
    string subject;
    string date;
    int arrival_num;

    Email(const string& cat, const string& subj, const string& dt, int arr_num)
        : category(cat), subject(subj), date(dt), arrival_num(arr_num) {}

    int getPriority() const {
        string lowerCat = toLower(category);
        auto it = PRIORITY.find(lowerCat);
        if (it != PRIORITY.end()) {
            return it->second;
        }
        return 1; // default if not found
    }

private:
    string toLower(const string& s) const {
        string res = s;
        transform(res.begin(), res.end(), res.begin(), ::tolower);
        return res;
    }
};

map<string, int> Email::PRIORITY = {
    {"boss", 5},
    {"subordinate", 4},
    {"peer", 3},
    {"importantperson", 2},
    {"otherperson", 1}
};

struct CompareEmail {
    bool operator()(const Email& a, const Email& b) {
        int a_priority = a.getPriority();
        int b_priority = b.getPriority();
        if (a_priority != b_priority) {
            return a_priority < b_priority;
        } else {
            return a.arrival_num < b.arrival_num;
        }
    }
};

class Inbox {
private:
    priority_queue<Email, vector<Email>, CompareEmail> priority_q;
    int arrival_num;
    vector<string> commands;

    vector<string> split(const string& s, char delimiter) {
        vector<string> tokens;
        string token;
        istringstream tokenStream(s);
        while (getline(tokenStream, token, delimiter)) {
            size_t start = token.find_first_not_of(" \t");
            size_t end = token.find_last_not_of(" \t");
            if (start != string::npos && end != string::npos)
                token = token.substr(start, end - start + 1);
            else
                token = "";
            tokens.push_back(token);
        }
        return tokens;
    }

    void newEmail(const string& data) {
        vector<string> parts = split(data, ',');
        if (parts.size() < 3) {
            cerr << "Invalid EMAIL command: " << data << endl;
            return;
        }
        string category = parts[0];
        string subject = parts[1];
        string date = parts[2];
        priority_q.push(Email(category, subject, date, arrival_num));
        arrival_num++;
    }

    void nextEmail() const {
        if (priority_q.empty()) {
            cout << "Invalid Command: No more emails in inbox...\n";
            return;
        }
        const Email& email = priority_q.top();
        cout << "Next Email:\n";
        cout << "\tSender: " << email.category << "\n";
        cout << "\tSubject: " << email.subject << "\n";
        cout << "\tDate: " << email.date << "\n\n";
    }

    void readEmail() {
        if (priority_q.empty()) {
            cout << "Invalid Command: Read all emails...\n";
            return;
        }
        priority_q.pop();
    }

    void countEmails() const {
        cout << "There are " << priority_q.size() << " emails to read\n\n";
    }

public:
    Inbox(const string& filename) : arrival_num(1) {
        ifstream file(filename);
        if (!file.is_open()) {
            throw runtime_error("File not found: " + filename);
        }
        string line;
        while (getline(file, line)) {
            size_t start = line.find_first_not_of(" \t");
            if (start != string::npos) {
                size_t end = line.find_last_not_of(" \t");
                line = line.substr(start, end - start + 1);
            } else {
                line = "";
            }
            if (!line.empty()) {
                commands.push_back(line);
            }
        }
        file.close();
    }

    void processCommands() {
        for (const string& line : commands) {
            // Split command and data using first space
            size_t spacePos = line.find(' ');
            string command, data;
            if (spacePos != string::npos) {
                command = line.substr(0, spacePos);
                data = line.substr(spacePos + 1);
                // Trim leading whitespace from data
                size_t dataStart = data.find_first_not_of(" \t");
                if (dataStart != string::npos) {
                    data = data.substr(dataStart);
                } else {
                    data = "";
                }
            } else {
                command = line;
                data = "";
            }

            if (command == "EMAIL") {
                newEmail(data);
            } else if (command == "NEXT") {
                nextEmail();
            } else if (command == "READ") {
                readEmail();
            } else if (command == "COUNT") {
                countEmails();
            } else {
                cout << "Unknown Command: skipping...\n";
            }
        }
    }
};

int main() {
    try {
        Inbox inbox("Assignment5_Test_File.txt");
        inbox.processCommands();
    } catch (const exception& e) {
        cerr << "Error: " << e.what() << endl;
        return 1;
    }
    return 0;
}