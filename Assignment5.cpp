/*
Program Name: EECS 348 Assignment 5
Description: Email Prioritization Program
Inputs: Test file labeled Assignment5_Test_File.txt
Output: Next email and number of unread emails

Collaborators: Code generated by Deepseek AI, referenced Assignment 1 for functionality and structure
               author debugged and annotated the AI generated code

Author: Aiman Boullaouz
Creation Date: 2/25/20225
*/

#include <iostream>  // Standard library for input and output
#include <fstream>   // Used for file handling operations
#include <sstream>   // Used for processing strings
#include <vector>    // Includes the the vector container for dynamic arrays
#include <queue>     // Used to implement the maxheap
#include <map>       // Supports mapping of email categories to priority levels (basically a dictionary)
#include <algorithm> // Includes a algorithm for case conversion
#include <cctype>    // Provides more functions to handle strings/chars
#include <stdexcept> // Adds ways to handle runtime errors with exceptions

using namespace std; // No longer need to use the standard library prefix std::

// Defines an Email class to encapsulate email attributes and behavior
class Email {
public:
    static map<string, int> PRIORITY; // Will contain a data structure mapping categories with priority values

    string category;  // Stores the sender category
    string subject;   // Holds the email subject
    string date;      // Stores the date of the email
    int arrival_num;  // Adds a way to uniquely identify every email

    // This is the class constructor that creates Email objects with category, subject, date, and arrival number
    Email(const string& cat, const string& subj, const string& dt, int arr_num)
        : category(cat), subject(subj), date(dt), arrival_num(arr_num) {}

    // Determines and returns the priority of an email based on its category
    int getPriority() const {
        string lowerCat = toLower(category); // Convert all categories to lowercase for fair comparison
        auto it = PRIORITY.find(lowerCat); // Get the priority from the mapping 
        if (it != PRIORITY.end()) {
            return it->second; // If we find the category return the priority level
        }
        return 1; // Default priority if category is unrecognized
    }

private:
    // Converts a given string to lowercase
    string toLower(const string& s) const {
        string res = s; // Creates a copy of the input string
        transform(res.begin(), res.end(), res.begin(), ::tolower); // Convertsa all the characters to lowercase
        return res; // Return the now lowercase string
    }
};

// Actually creating the data sttructure that maps all the categories and priority values
map<string, int> Email::PRIORITY = {
    {"boss", 5},
    {"subordinate", 4},
    {"peer", 3},
    {"importantperson", 2},
    {"otherperson", 1}
};

// Defines a structure that compares emails to order them by priority
struct CompareEmail {
    bool operator()(const Email& a, const Email& b) {
        int a_priority = a.getPriority(); // Get priority of the first email
        int b_priority = b.getPriority(); // Get priority of the second email
        if (a_priority != b_priority) { // If priorities differ, compare them
            return a_priority < b_priority; // Higher priority emails come first
        } else {
            return a.arrival_num < b.arrival_num; // If priorities match, earlier emails come first
        }
    }
};

// Define an Inbox class to handle email operations
class Inbox {

private:
    priority_queue<Email, vector<Email>, CompareEmail> priority_q; // Priority queue that sorts emails by priority
    int arrival_num; // Counter to track the order of email arrivals
    vector<string> commands; // Vector (array that can grow and shrink) that will hold all the commands from the test file

    // Splits a string argument based on a delimiter and trims whitespace from the portions that were split
    vector<string> split(const string& s, char delimiter) {
        vector<string> tokens; // Dynamic array full of strings to store the split pieces
        string token; // Creating a empty string variable

        /*
        Below section takes the string argument and iterates through it breaking the string down into
        pieces, formatting those pieces by removing whitespace, then adds the pieces to a dynamic array
        until the string argument has been completley read through.
        */
        istringstream tokenStream(s); // Create a string stream from input.
        while (getline(tokenStream, token, delimiter)) { // Extract substrings
            size_t start = token.find_first_not_of(" \t"); // Find first non-whitespace character
            size_t end = token.find_last_not_of(" \t"); // Find last non-whitespace character
            if (start != string::npos && end != string::npos)
                token = token.substr(start, end - start + 1); // Trim surrounding whitespace
            else
                token = ""; // If only whitespace, set token to empty string
            tokens.push_back(token); // Add token to vector
        }
        return tokens; // Return split parts
    }

    // Processes a new email and adds it to the priority queue
    void newEmail(const string& data) {
        vector<string> parts = split(data, ','); // Split data by commas
        if (parts.size() < 3) { // Makes sure all fields are accounted for before trying to make a email object
            cerr << "Invalid EMAIL command: " << data << endl; // Print error if format is incorrect
            return;
        }
        string category = parts[0]; //Getting the category
        string subject = parts[1]; // Getting the Subject
        string date = parts[2];  //Getting the date
        priority_q.push(Email(category, subject, date, arrival_num)); // Creating a email and adding it to the heap
        arrival_num++; // Increment arrival order counter
    }

    // Displays the next email to be read from the inbox
    void nextEmail() const {
        if (priority_q.empty()) { // Checks for unread emails
            cout << "Invalid Command: No more emails in inbox...\n";  // Printing error to screen
            return;
        }
        const Email& email = priority_q.top(); // Access the highest-priority email

        //Printing out the email
        cout << "Next Email:\n";
        cout << "\tSender: " << email.category << "\n";
        cout << "\tSubject: " << email.subject << "\n";
        cout << "\tDate: " << email.date << "\n\n";
    }

    // Marks the top email as read by removing it from the queue
    void readEmail() {
        //Check if the heap is empty
        if (priority_q.empty()) {
            cout << "Invalid Command: Read all emails...\n";   // print error to screen
            return;
        }
        priority_q.pop(); // Else read the highest priority email from queue
    }

    // Prints the total count of unread emails
    void countEmails() const {
        cout << "There are " << priority_q.size() << " emails to read\n\n";
    }

public:
    // The Inbox object constructor takes a file as input
    Inbox(const string& filename) : arrival_num(1) {
        ifstream file(filename); // Open file for reading

        //if the file isnt open then we cant find the file
        if (!file.is_open()) {
            throw runtime_error("File not found: " + filename); // Throw error if file doesn't exist
        }

        string line; //initializing a string variable
        while (getline(file, line)) { // Read file line by line
            size_t start = line.find_first_not_of(" \t"); // Trim leading spaces

            // Check if we found a valid starting position in the string
            if (start != string::npos) {
                size_t end = line.find_last_not_of(" \t"); // Trim trailing spaces
                line = line.substr(start, end - start + 1); // Gets a substring
            } else {
                line = "";  // else line is a empty string
            }
            if (!line.empty()) {
                commands.push_back(line); // Store non-empty commands
            }
        }
        file.close(); // Close file after reading
    }

    // Processes all stored commands sequentially
    void processCommands() {
        // Iterate over the lines in the commands vector
        for (const string& line : commands) {

            /*
            The below section of code is a complicated way of isolating the EMAIL command from the 
            data that the email is supposed to contain. The code also handles the other commands
            */
            size_t spacePos = line.find(' ');   // Finding the position of the space between the command and data
            string command, data;               //Initializing empty string variables
            // If the space position exists this if block will run
            if (spacePos != string::npos) {
                command = line.substr(0, spacePos);     //The command is the text between index 0 and the space
                data = line.substr(spacePos + 1);       //The data is the rest of the line
                size_t dataStart = data.find_first_not_of(" \t");  //Gets the index of the first character in the remaining data

                // if datastart is a valid index
                if (dataStart != string::npos) {
                    data = data.substr(dataStart);  // data is the remaining characters after the starting index
                } else {
                    data = "";  //Otherwise we have no data
                }
            } else {
                command = line;     //For commands besides EMAIL the command is the only thing on the line
                data = "";          //No data to consider
            }

            // After isolating the command from the line apply the relevant method function for the command
            if (command == "EMAIL") newEmail(data);
            else if (command == "NEXT") nextEmail();
            else if (command == "READ") readEmail();
            else if (command == "COUNT") countEmails();
            else cout << "Unknown Command: skipping...\n";
        }
    }
};

// Main function creates class objects and runs the program
int main() {
    try {
        Inbox inbox("Assignment5_Test_File.txt");  // Creating a inbox from the test file
        inbox.processCommands();    // Getting the commands from the file
    } catch (const exception& e) {      //Catching general exceptions from the program
        cerr << "Error: " << e.what() << endl;  //Print the exception to the terminal
        return 1;
    }
    return 0;
}
